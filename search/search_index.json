{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Token-based (Email &amp; Password )","text":"<p>This guided tutorial is part of a series of articles on building an authenticated backend with TypeScript, Hono, PostgreSQL, and Prisma. In this first tutorial, we'll look at how to secure the REST API with password authentication using Prisma for token storage and implement authorization.</p>"},{"location":"#what-you-will-learn-today","title":"What you will learn today","text":"<p>In this tutorial, you will explore the fundamental concepts of authentication and authorization, understand their distinctions, and learn how to implement email-based password authentication and authorization using JSON Web Tokens (JWT) with Hono to secure your REST API. Specifically, you will develop the following aspects:</p> <ol> <li>Password Authentication: Implement a sign-up and login system where users receive a unique token via email. Users complete the authentication process by sending the received token to the API, which then issues a long-lived JWT token granting access to authenticated API endpoints.</li> <li>Authorization: Incorporate authorization logic to control which resources authenticated users can access and manipulate based on their roles or permissions.</li> </ol>"},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#assumed-knowledge","title":"Assumed knowledge","text":"<p>This tutorial assumes a basic understanding of TypeScript, Node.js, and relational databases. If you're proficient in JavaScript but new to TypeScript, you can still follow along comfortably. The tutorial series will utilize PostgreSQL, but most of the concepts are applicable to other relational databases such as MySQL. Familiarity with REST principles is advantageous. Some prior knowledge of Prisma is required.</p>"},{"location":"#development-environment","title":"Development environment","text":"<p>Ensure you have the following tools installed on your machine:</p> <ul> <li>Bun v 1.x or later</li> </ul> <p>If you're using Visual Studio Code, the Prisma extension is recommended for syntax highlighting, formatting, and other helpers.</p>"},{"location":"#clone-the-repository","title":"Clone the repository","text":"<p>The source code for the tutorial can be found on [GitHub].</p> <p>To get started, clone the repository and install the dependencies:</p> <pre><code>git clone https://github.com/rubcstswe/web102-hono-auth-jwt-prisma-forked.git\ncd web102-hono-auth-jwt-prisma-forked\nbun install\n</code></pre> <p>Note</p> <p>The repository has already implemented a basic REST API with Hono and Prisma. The API includes a user model and a few endpoints to create, read, update, and delete users. The API is not secured and can be accessed without authentication.</p>"},{"location":"#data-modelschema","title":"Data Model/Schema","text":"<p>The fundamental building block of the Prisma schema is model. Every model maps to a database table.</p> <p>Here is a basic schema showing the basic bank account in a 1-n relationship to a user from the project repository that you have cloned:</p> schema.prisma<pre><code>model User {\n  id      String    @id @default(uuid())\n  email   String    @unique\n  Account Account[]\n}\n\nmodel Account {\n  id      String @id @default(uuid())\n  userId  String\n  user    User   @relation(fields: [userId], references: [id])\n  balance Int    @default(0)\n}\n</code></pre> <p>Note</p> <p>The <code>User</code> model has a one-to-many relationship with the <code>Account</code> model. A user can have multiple accounts, but an account belongs to only one user.</p>"},{"location":"#rest-api-endpoints","title":"REST API Endpoints","text":"Method Endpoint Description <code>GET</code> <code>http://localhost:3000/:userId/account/balance</code> Retrieves all accounts owned by the user with its' balance <p>Where the user id is given as <code>7a038d5b-65aa-45c5-9f7e-c9b86a071099</code></p> <p>Let's build a http request to get the balance of the account of the user with the id <code>7a038d5b-65aa-45c5-9f7e-c9b86a071099</code></p>"},{"location":"#request","title":"Request","text":"<pre><code>http://localhost:3000/7a038d5b-65aa-45c5-9f7e-c9b86a071099/account/balance\n</code></pre>"},{"location":"#response","title":"Response","text":"<pre><code>{\n  \"data\": {\n    \"Account\": [\n      {\n        \"balance\": 0,\n        \"id\": \"75a34064-f8c4-4a7e-90dd-4958c452fbf4\"\n      }\n    ]\n  }\n}\n</code></pre> <p>Question</p> <p>Should anyone be able to access and view any user's bank account balance?</p> <p>If you realised that the API is not secured and can be accessed without authentication, you are right! </p> <p>Technically, only the user who owns the account should be able to access the account balance.</p> <p>In the next step, we will implement a password authentication system using Prisma for token storage and implement authorization.</p>"},{"location":"#authentication-and-authorization-concepts","title":"Authentication and authorization concepts","text":"<p>Before going into the implementation, let's explore the concepts of authentication and authorization. While these terms are often used interchangeably, they serve distinct purposes and work together to secure applications.</p> <p>Authentication is the process of verifying a user's identity. In other words, it answers the question \"Who are you?\" One real-world example of authentication is a valid passport. By matching your appearance with the official document's photo and details (which are difficult to forge), your passport authenticates that you are the person you claim to be. When you arrive at the airport, presenting your passport allows you to proceed through security.</p> <p>On the other hand, authorization is the process of verifying what resources or actions a user is permitted to access or perform. It answers the question \"What are you allowed to do?\" Continuing with the airport example, authorization occurs when you present your boarding pass (which is typically scanned and verified against the flight's passenger database). The ground attendant then authorizes you to board the flight.</p> <p>In summary, authentication establishes identity, while authorization determines access privileges. These complementary processes work together to secure applications and ensure that only authenticated users can access the resources and perform the actions they are authorized for.</p>"},{"location":"#authentication-in-web-applications","title":"Authentication in web applications","text":"<p>Web applications typically use a username and password to authenticate users. If a valid username and password are verified and correct, the server can verify that you're the user you claim to be because the password is supposed to be only known to you and the application.</p> <p>Note</p> <p>Web applications that use username/password authentication rarely store the password in clear text in the database. Instead, they use a technique called hashing to store a hash of the password. This allows the backend to verify the password without knowing it.</p> <p>A hash function is a mathematical function that takes arbitrary input and always generates the same fixed-length string/number given the same input. The power of hash function lies in that you can go from a password to a hash but not from a hash to a password.</p> <p>This allows verifying the password submitted by the user without storing the actual password. Storing password hashes protects users in the case of breached accounts.</p>"},{"location":"#authentication-and-signuplogin-flow","title":"Authentication and signup/login flow","text":"<p>Email-based password authentication is a two-step process.</p> <ol> <li> <p>Register: The user provides an email and password to create an account. The server stores the user's email and a hashed password in the database.</p> </li> <li> <p>Login: The user provides their email and password to authenticate themselves. The server verifies the email and password against the stored hash. If the credentials are correct, the server issues a long-lived JWT token that the user can use to access authenticated API endpoints.</p> </li> </ol> <p>A successful authentication flow will look as follows:</p> <pre><code>sequenceDiagram\n  autonumber\n  User-&gt;&gt;Server: register {email, password}\n  Server-&gt;&gt;Database: Create user (if new/doesnt exist)\n  Server--&gt;&gt;User: HTTP 200 OK {message: \"User created successfully\"}\n  User-&gt;&gt;Server: login {email, password}\n  Server--&gt;&gt;Database: Verify if email is in the database and the password matches the stored hash\n  Server--&gt;&gt;User: JWT token sent back in authorization header\n  User-&gt;&gt;Server: User passes JWT auth token in the authorization header in subsequent requests</code></pre> <ol> <li>The user calls the /register endpoint in the API with the email and password in the payload to begin the registration process.</li> <li>If the email is new, the user is created in the User table and the password is hashed and stored in the database.</li> <li>he user calls the /login endpoint in the API with the email and password in the payload to begin the authentication process.</li> <li>The backend validates the email and password sent by the user. If the email exists and the password matches the stored hash, the user is authenticated.</li> <li>The JWT token is sent back to the user via the Authorization header.</li> </ol> <p>Authentication token: A JWT token with tokenId in its payload. This token can be used to access protected endpoints by passing it in the Authorization header when making a request to the API. The token is long-lived in the sense that it's valid for 12 hours at least.</p>"},{"location":"#adding-a-hashpassword-field-to-the-user-model","title":"Adding a hashPassword field to the User Model","text":"<p>To store the hashed password, we need to add a new field called <code>hashPassword</code> to the User model in the Prisma schema. This field will store the hashed password.</p> schema.prisma<pre><code>model User {\n  id           String    @id @default(uuid())\n  email        String    @unique\n  hashPassword String\n  Account      Account[]\n}\n</code></pre> <p>To update the database schema, run the commands as follows:</p> <pre><code>bunx prisma db push\nbunx prisma generate\n</code></pre>"},{"location":"#add-registration-functionality","title":"Add registration functionality","text":"<p>To implement the registration functionality, we need to create a new endpoint that allows users to register by providing an email and password. The server will hash the password and store the email and hashed password in the database.</p>"},{"location":"#register-endpoint","title":"Register endpoint","text":"<p>The register endpoint is a POST request that accepts an email and password in the request body. The server will hash the password and store the email and hashed password in the database.</p> <pre><code>POST http://localhost:3000/register\n</code></pre>"},{"location":"#request-body","title":"Request Body","text":"<pre><code>{\n    \"email\": \"test@gmail.com\",\n    \"password\": \"123456\"\n}\n</code></pre>"},{"location":"#response_1","title":"Response","text":"<pre><code>{\n    \"message\": \"User created successfully\"\n}\n</code></pre>"},{"location":"#implementing-the-register-endpoint","title":"Implementing the register endpoint","text":"<p>To implement the register endpoint, we need to create a new route in the <code>src/index.ts</code> file.</p> src/index.ts<pre><code>app.post(\"/register\", async (c) =&gt; {\n  try {\n    const body = await c.req.json();\n\n    const bcryptHash = await Bun.password.hash(body.password, {\n      algorithm: \"bcrypt\",\n      cost: 4, // number between 4-31\n    });\n\n    const user = await prisma.user.create({\n      data: {\n        email: body.email,\n        hashedPassword: bcryptHash,\n        Account: {\n          create: {\n            balance: 0,\n          },\n        },\n      },\n    });\n\n    return c.json({ message: `${user.email} created successfully}` });\n  } catch (error) {\n    return c.json({ error: error });\n  }\n});\n</code></pre> <ol> <li>The route listens for POST requests to the <code>/register</code> endpoint.</li> <li>The request body is parsed to extract the email and password.</li> <li>The password is hashed using the <code>Bun.password.hash</code> method.</li> <li>The user is created in the database with the email and hashed password.</li> <li>The <code>Account</code> model is created with a default balance of 0.</li> <li>A success message is returned if the user is created successfully.</li> <li>If an error occurs during the registration process, the server returns a JSON response with the error message.</li> </ol>"},{"location":"#handling-exceptions-and-errors-from-prisma-orm","title":"Handling exceptions and errors from Prisma ORM","text":"<p>In the code snippet above, we use a try-catch block to handle exceptions and errors that may occur during the registration process. If an error occurs, the server will return a JSON response with the error message.</p> <p>However, we need to know the exact error that occurred. To do this, we can use the <code>PrismaClientKnownRequestError</code> class to check if the error is a known Prisma error. If it is, we can return a more user-friendly error message.</p> src/index.ts<pre><code>import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { PrismaClient, Prisma } from \"@prisma/client\";\n</code></pre> src/index.ts<pre><code>app.post(\"/register\", async (c) =&gt; {\n  try {\n    const body = await c.req.json();\n\n    const bcryptHash = await Bun.password.hash(body.password, {\n      algorithm: \"bcrypt\",\n      cost: 4, // number between 4-31\n    });\n\n    const user = await prisma.user.create({\n      data: {\n        email: body.email,\n        hashedPassword: bcryptHash,\n        Account: {\n          create: {\n            balance: 0,\n          },\n        },\n      },\n    });\n\n    return c.json({ message: `${user.email} created successfully}` });\n  } catch (e) {\n    if (e instanceof Prisma.PrismaClientKnownRequestError) {\n      // The .code property can be accessed in a type-safe manner\n      if (e.code === 'P2002') {\n        console.log(\n          'There is a unique constraint violation, a new user cannot be created with this email'\n        )\n        return c.json({ message: 'Email already exists' })\n      }\n    }\n    throw e\n  }\n});\n</code></pre>"},{"location":"#add-login-functionaliy","title":"Add login functionaliy","text":"<p>To implement the login functionality, we need to create a new endpoint that allows users to authenticate by providing an email and password. The server will verify the email and password against the stored hash. If the credentials are correct, the server will issue a long-lived JWT token that the user can use to access authenticated API endpoints.</p>"},{"location":"#login-endpoint","title":"Login endpoint","text":"<p>The login endpoint is a POST request that accepts an email and password in the request body. The server will verify the email and password against the stored hash. If the credentials are correct, the server will issue a long-lived JWT token that the user can use to access authenticated API endpoints.</p> <pre><code>POST http://localhost:3000/login\n</code></pre>"},{"location":"#request-body_1","title":"Request Body","text":"<pre><code>{\n    \"email\": \"test@gmail.com\",\n    \"password\": \"123456\"\n}\n</code></pre>"},{"location":"#response_2","title":"Response","text":"<pre><code>{\n    \"message\": \"Login successful\",\n    \"token\": \"JWT_TOKEN_LIVES_HERE\"\n}\n</code></pre>"},{"location":"#implementing-the-login-endpoint","title":"Implementing the login endpoint","text":"<p>To implement the login endpoint, we need to create a new route in the <code>src/index.ts</code> file.</p> src/index.ts<pre><code>app.post(\"/login\", async (c) =&gt; {\n  try {\n    const body = await c.req.json();\n\n    const user = await prisma.user.findUnique({\n      where: { email: body.email },\n      select: { id: true, hashedPassword: true },\n    });\n\n    if (!user) {\n      return c.json({ message: \"User not found\" });\n    }\n\n    const match = await Bun.password.verify(body.password, user.hashedPassword,\"bcrypt\");\n\n    if (match) {\n      return c.json({ message: \"Login successful\" });\n    } else {\n      throw new HTTPException(401, { message: \"Invalid credentials\" });\n    }\n\n  } catch (error) {\n    throw new HTTPException(401, { message: 'Invalid credentials' })\n  }\n});\n</code></pre> <ol> <li>The route listens for POST requests to the <code>/login</code> endpoint.</li> <li>The request body is parsed to extract the email and password.</li> <li>The user is fetched from the database using the email.</li> <li>If the user is not found, the server returns a JSON response with the message \"User not found\".</li> <li>The password is verified against the stored hash using the <code>Bun.password.verify</code> method.</li> <li>If the password matches the stored hash, the server returns a JSON response with the message \"Login successful\".</li> <li>If the password does not match the stored hash, the server throws an HTTPException with a status code of 401 and a message \"Invalid credentials\".</li> </ol> <p>To do this we need to import the <code>HTTPException</code> class from Hono.</p> src/index.ts<pre><code>import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { PrismaClient, Prisma } from \"@prisma/client\";\nimport { HTTPException } from \"hono/http-exception\";\n</code></pre> <ol> <li>If an error occurs during the login process, the server returns a JSON response with the message \"Login failed\".</li> </ol>"},{"location":"#handling-the-jwt-token-in-the-login-response","title":"Handling the JWT token in the login response","text":"<p>In the code snippet above, we verify the password against the stored hash. If the password matches the stored hash, the server returns a JSON response with the message \"Login successful\".</p> <p>However, we need to issue a long-lived JWT token that the user can use to access authenticated API endpoints. </p> <p>To do this, we can use the JWT Authentication Helper from Hono. The helper provides methods to create and verify JWT tokens. </p> <p>To use this helper, you can import it as follows:</p> src/index.ts<pre><code>import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { PrismaClient, Prisma } from \"@prisma/client\";\nimport { HTTPException } from \"hono/http-exception\";\nimport { decode, sign, verify } from 'hono/jwt'\n</code></pre> <p>Next, we can create a JWT token with the user's unique id as the payload and sign it with a secret key. The token can be sent back to the user in the login response.</p> src/index.ts<pre><code>app.post(\"/login\", async (c) =&gt; {\n  try {\n    const body = await c.req.json();\n\n    const user = await prisma.user.findUnique({\n      where: { email: body.email },\n      select: { id: true, hashedPassword: true },\n    });\n\n    if (!user) {\n      return c.json({ message: \"User not found\" });\n    }\n\n    const match = await Bun.password.verify(\n      body.password,\n      user.hashedPassword,\n      \"bcrypt\"\n    );\n\n    if (match) {\n      const payload = {\n        sub: user.id,\n        exp: Math.floor(Date.now() / 1000) + 60 * 60, // Token expires in 60 minutes\n      };\n      const secret = \"mySecretKey\";\n      const token = await sign(payload, secret);\n      return c.json({ message: \"Login successful\", token: token });\n    } else {\n      throw new HTTPException(401, { message: \"Invalid credentials\" });\n    }\n  } catch (error) {\n    throw new HTTPException(401, { message: 'Invalid credentials' })\n  }\n});\n</code></pre> <p>Warning</p> <p>The secret key used to sign the JWT token should be kept secure and not exposed in the code. In a production environment, you should store the secret key in an environment variable or a secure location.</p>"},{"location":"#implementing-authorization-on-protected-endpoints","title":"Implementing authorization on protected endpoints","text":"<p>To implement authorization, we need to create a middleware that verifies the JWT token sent by the user in the Authorization header. If the token is valid, the user is authenticated and can access the protected endpoints.</p>"},{"location":"#middleware-for-verifying-jwt-tokens","title":"Middleware for verifying JWT tokens","text":"<p>To create a middleware for verifying JWT tokens, we need to create a new function that checks the Authorization header for the JWT token. If the token is valid, the user is authenticated and can access the protected endpoints.</p> <p>Thankfully, Hono provides a middleware function called <code>jwt</code> that verifies the JWT token and decodes the payload. The middleware function can be used to protect the endpoints that require authentication.</p> <p>The JWT Auth Middleware provides authentication by verifying the token with JWT. Authorization header value or cookie value specified by the cookie option will be used as a token.</p> <p>To use the JWT Auth Middleware, you can import it as follows:</p> src/index.ts<pre><code>import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { PrismaClient, Prisma } from \"@prisma/client\";\nimport { HTTPException } from \"hono/http-exception\";\nimport { decode, sign, verify } from \"hono/jwt\";\nimport { jwt } from 'hono/jwt'\nimport type { JwtVariables } from 'hono/jwt'\n</code></pre> <p>Specify the variable types to infer the <code>c.get('jwtPayload')</code> type.</p> src/index.ts<pre><code>import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { PrismaClient, Prisma } from \"@prisma/client\";\nimport { HTTPException } from \"hono/http-exception\";\nimport { decode, sign, verify } from \"hono/jwt\";\nimport { jwt } from 'hono/jwt'\nimport type { JwtVariables } from 'hono/jwt'\n\ntype Variables = JwtVariables\n\nconst app = new Hono&lt;{ Variables: Variables }&gt;()\n</code></pre> <p>Next, we can use the middleware function called <code>jwt</code> that verifies the JWT token sent by the user in the Authorization header.</p> src/index.ts<pre><code>app.use(\n  \"/protected/*\",\n  jwt({\n    secret: 'mySecretKey',\n  })\n);\n</code></pre> <p>Warning</p> <p>The secret key used to sign the JWT token should be kept secure and not exposed in the code. In a production environment, you should store the secret key in an environment variable or a secure location.</p> <p>The middleware function <code>jwt</code> verifies the JWT token sent by the user in the Authorization header. If the token is valid, the user is authenticated and can access the protected endpoints.</p>"},{"location":"#protected-endpoint","title":"Protected endpoint","text":"<p>The protected endpoint is a GET request that retrieves the user's account balance. The server will verify the JWT token sent by the user in the Authorization header. If the token is valid, the user is authenticated and can access the protected endpoint.</p> <pre><code>GET http://localhost:3000/protected/account/balance\n</code></pre>"},{"location":"#request-headers","title":"Request Headers","text":"<pre><code>Authorization\nBearer JWT\n</code></pre>"},{"location":"#response_3","title":"Response","text":"<pre><code>{\n    \"data\": {\n        \"Account\": [\n            {\n                \"balance\": 0,\n                \"id\": \"75a34064-f8c4-4a7e-90dd-4958c452fbf4\"\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"#implementing-the-protected-endpoint","title":"Implementing the protected endpoint","text":"<p>To implement the protected endpoint, we need to create a new route in the <code>src/index.ts</code> file.</p> src/index.ts<pre><code>app.use(\n  \"/protected/*\",\n  jwt({\n    secret: 'mySecretKey',\n  })\n);\n\napp.get(\"/protected/account/balance\", async (c) =&gt; {\n  const payload = c.get('jwtPayload')\n  if (!payload) {\n    throw new HTTPException(401, { message: \"Unauthorized\" });\n  }\n  const user = await prisma.user.findUnique({\n    where: { id: payload.sub },\n    select: { Account: { select: { balance: true, id: true } } },\n  });\n\n  return c.json({ data: user });\n});\n</code></pre> <ol> <li>The middleware function <code>jwt</code> verifies the JWT token sent by the user in the Authorization header.</li> <li>The protected endpoint listens for GET requests to the <code>/protected/account/balance</code> endpoint.</li> <li>The middleware function <code>jwt</code> decodes the JWT token and stores the payload in the context.</li> <li>If the JWT token is not valid, the server throws an HTTPException with a status code of 401 and a message \"Unauthorized\".</li> <li>The user is fetched from the database using the user id from the JWT token.</li> <li>The user's account balance is returned in the JSON response.</li> </ol>"}]}